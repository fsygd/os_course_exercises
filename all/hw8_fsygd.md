### 8.1 虚拟存储的需求背景

1. 寄存器、高速缓存、内存、外存的访问特征？

   一般来说，按访问时间来排，从快到慢是寄存器、高速缓存、内存和外存，存储容量则是越来越大

2. 如何理解计算机中的存储层次结构所的理想状态是“均衡繁忙”状态？

   指的是存储层次结构中各个层次都经常被访问到，而不会出现长时间的空闲，但也不会成为整个系统的瓶颈，这样能保证每个层级的成本没有大的浪费，这样理想的状态是很难实现的

3. 在你写程序时遇到过内存不够的情况吗？尝试过什么解决方法？

   有，比如排序的时候可以分块来做，每次把一部分排好序，最后再合并

### 8.2 覆盖和交换

1. 什么是覆盖技术？使用覆盖技术的程序开发者的主要工作是什么？

   划分程序，必要的部分常驻内存，可选部分放在程序模块中，要用的时候再加载到内存中，相互独立的模块被加载的时候可以相互覆盖

   程序开发者需要在编程的时候对程序的模块进行划分，确定模块之间的独立性，最终确定哪些模块之间可以相互覆盖

2. 什么是交换技术？覆盖与交换有什么不同？

   当一个进程运行时或准备运行时需要的内存空间不够时，把当前不在使用的进程的地址空间移到外存中去，以此获得更大的内存空间

   不同之处在于交换技术换入换出的基本单位是进程，解决的是多个进程占用内存导致某个进程空间不够的问题；覆盖技术解决的是一个进程在整个内存空间中放不下，在程序内部进行划分覆盖的问题。

3. 覆盖和交换技术在现代计算机系统中还有需要吗？可能用在什么地方？

   覆盖技术基本已经没有使用了，交换技术的思想还在使用，不过交换的粒度一般都是以页为单位

4. 如何分析内核模块间的依赖关系？

   编译器在编译的时候可以知道某个模块可能会跳转到哪些模块中，根据跳转关系可以建立一张图

5. 如何获取内核模块间的函数调用列表？

   静态代码分析工具，通过词法分析、语法分析、控制流、数据流技术对代码本身进行分析

   动态函数调用追踪，记录下运行时各个模块之间的调用行为

### 8.3 局部性原理

1. 什么是时间局部性、空间局部性和分支局部性？

   时间局部性：一条指令或者一个数据的连续两次访问，往往在一个比较短的时间间隔里

   空间局部性：当前指令的指令附近的几条指令，当前访问的数据相邻的一些数据，往往集中在一个较小的区域里

   分支局部性：一条跳转指令的两次执行，很可能跳转到同一个内存地址

2. 如何提高程序执行时的局部性特征？

   访问大块内存的时候尽量让内存的地址连续

3. 排序算法的局部性特征？

- 参考：[九大排序算法再总结](http://blog.csdn.net/xiazdong/article/details/8462393)

### 8.4 虚拟存储概念

1. 什么是虚拟存储？它与覆盖和交换的区别是什么？它有什么好处和挑战？

   一个进程运行的时候只将部分代码和数据的页或段加载到物理内存中，如果要访问的代码或者数据不在内存中，发生缺页或者缺段，就需要操作系统把外存中的页或者段移入内存，操作系统还要将暂时不用的页或者段移入外存

   与覆盖的区别是不用考虑程序内部的逻辑性，减轻了程序员的负担

   与交换的区别是换入换出的基本单位变成了页或者段，只是进程的一部分，而不是整个进程

2. 虚拟存储需要什么样的支持技术？

   硬件需要完成地址的转换

   操作系统需要控制页或者段的换入和换出

### 8.5 虚拟页式存储

1. 什么是虚拟页式存储？缺页中断处理的功能是什么？

   以页为换入换出基本单位的虚拟存储，缺页中断处理的功能是当发现需要的指令或数据所在的页不在物理内存中时，能把外存中的内容移入物理内存，再次执行指令的时候就不会发生缺页

2. 为了支持虚拟页式存储的实现，页表项有什么修改？

   主要是增加了标志位。

   驻留位：该页是否在内存中

   修改位：该页是否被修改过，如果修改过，在被换出的时候需要把内容写入外存，否则可以直接设为无效

   保护位：是否可执行、可读、可写

   访问位：是否被访问过（读或写），用于页面置换算法中对换出页的选择

3. 页式存储和虚拟页式存储的区别是什么？

   虚拟页式存储在页式存储的基础上增加了对页换入的请求以及页面的置换

### 8.6 缺页异常

1. 缺页异常的处理流程？

   记缺失的虚拟页为p，找到一个空闲的物理帧f，把缺失的页面的内容从外存写入f，将p的驻留位置为1，重新执行导致缺页异常的指令

   如果找不到空闲的物理帧，则根据页面置换算法找到要置换的帧f，对应的虚拟页为q，如果q被修改过，则需要先将内容写回外存，将q的驻留位设置为0，再从上面的把缺失页面内容从外存写入f开始做起

2. 虚拟页式存储管理中有效存储访问时间是如何计算的？

   $$有效存储访问时间=访存时间\times(1-缺页率p)+缺页率p\times页缺失异常处理例程时间$$

## 个人思考题

### 内存访问局部性的应用程序例子

------

(1)(w4l2)下面是一个体现内存访问局部性好的简单应用程序例子，请参考，在linux中写一个简单应用程序，体现内存局部性差，并给出其执行时间。

```
#include <stdio.h>
#define NUM 1024
#define COUNT 10
int A[NUM][NUM];
void main (void) {
  int i,j,k;
  for (k = 0; k<COUNT; k++)
  for (i = 0; i < NUM; i++)
  for (j = 0; j	 < NUM; j++)
      A[i][j] = i+j;
  printf("%d count computing over!\n",i*j*k);
}
```

可以用下的命令来编译和运行此程序：

```
gcc -O0 -o goodlocality goodlocality.c
time ./goodlocality
```

可以看到其执行时间。

仿照写了badlocality.c

```C
#include <stdio.h>
#define NUM 1024
#define COUNT 10
int A[NUM][NUM];
void main(void) {
  int i,j,k;
  for (k = 0; k < COUNT; k++)
  for (j = 0; j < NUM; j++)
  for (i = 0; i < NUM; i++)
    A[i][j] = i+j;
  printf("%d count computing over!\n", i*j*k);
}
```

goodlocality的执行时间是0.034s，badlocality的执行时间是0.182s。

## 小组思考题目

------

### 缺页异常嵌套

（1）缺页异常可用于虚拟内存管理中。如果在中断服务例程中进行缺页异常的处理时，再次出现缺页异常，这时计算机系统（软件或硬件）会如何处理？请给出你的合理设计和解释。

> 提示：<https://en.wikipedia.org/wiki/Double_fault> 和 <https://en.wikipedia.org/wiki/Triple_fault>

### 缺页异常次数计算

（2）如果80386机器的一条机器指令(指字长4个字节)，其功能是把一个32位字的数据装入寄存器，指令本身包含了要装入的字所在的32位地址。这个过程在OS合理处理情况下最多会引起几次缺页异常？

> 提示：内存中的指令和数据的地址需要考虑地址对齐和不对齐两种情况。需要考虑页目录表项invalid、页表项invalid、TLB缺失等是否会产生异常？

最差的情况下地址不对齐，需要两次访存，每次访存的页目录项可能不在内存中，即页表不在内存中，属于缺页异常，把页表换入内存后，可能会发现该页不在内存中，需要从外存换入，这又会产生一次缺页异常，所以最多是4次缺页异常。

