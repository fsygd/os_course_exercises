## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？

代码段寄存器 CS（Code Segment）存放当前指令所在段的段基址，相应的偏移量则由IP提供
数据段寄存器 DS（Data Segment）指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址
堆栈段寄存器 SS（Stack Segment）指出当前堆栈的底部地址，即存放堆栈段的段基址
附加段寄存器 ES（Extra Segment）指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段
附加段寄存器 FS
附加段寄存器 GS

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？
当前特权级CPL表示当前程序所处的特权级，存在CS寄存器中
描述符特权级DPL表示某个段的特权级，用来实现保护机制，存在段描述符中
请求特权级RPL表示进程对段访问的请求权限，意思是当前进程想要的请求权限，保存在选择子的最低两位。
访问条件是max(CPL, RPL) <= DPL
3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？
按照压栈顺序：SS（如果需要转换特权级），ESP（如果需要转换特权级），EFlags，CS，eip，ERROR CODE（没有的话软件会把0压入栈），用户态中断的时候需要转换特权级，需要把栈的位置信息SS和ESP入栈
2. 为什么在用户态的中断响应要使用内核堆栈？
因为中断响应保存的信息和中断处理过程中的结果需要被保护起来，不能被用户态的应用程序访问
3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?
trap类型中断门的中断描述符上有一位istrap为1，调用时不关中断
interrupt类型中断门的中断描述符上的istrap为0，调用时关中断
如果不做区分，会重复触发中断，同一个中断一直循环，却没有进行处理

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？
  `read_ebp` 内联使得我们可以取得当前ebp的值，如果不内联就会调用函数，会改变ebp寄存器的值
  `read_eip` 通过ebp指向的内存的上一个单元(高地址，如下图所示)，可以得到当前函数的返回地址，不内联的话又调用了一个函数，当前地址+1就会被作为返回地址入栈，被read_eip获得
  +---------------------+    high
  | return addrs   |
  +---------------------+
  |  old ebp           |    <-----ebp
  +---------------------+    low
### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？
  不使能，因为刚加电时还没有加载中断向量表