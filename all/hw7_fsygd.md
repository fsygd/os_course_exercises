## 第七讲视频相关思考题

### 7.1 了解x86保护模式中的特权级

1. X86有几个特权级？

   X64一共有4个特权级，ucore中用到了2个，ring0内核态和ring3用户态

2. 不同特权级有什么区别？

   不同的段有不同的访问权限，低特权级不能访问高特权级的数据，低特权级无法执行特权指令

3. 请说明CPL、DPL和RPL在中断响应、函数调用和指令执行时的作用。

   中断响应时：要求CPL<=门的DPL，这样可以限制用户态产生中断，跳转到ISR时，CPL变为ISR所在的段的DPL

   指令执行时遇到访问会判断max(CPL，段寄存器的RPL)<=要访问的段在GDT中的DPL，满足条件才能访存

4. 写一个示例程序，完成4个特权级间的函数调用和数据访问时特权级控制的作用。

### 7.2 了解特权级切换过程

1. 一条指令在执行时会有哪些可能的特权级判断？

   访问数据段的时候，访问页的时候，进入中断服务例程的时候

2. 在什么情况下会出现特权级切换？

   在用户态执行int指令产生软中断会切换到内核态

   内核态执行iret指令时如果内核栈上的CS中的低两位CPL为3，则执行完后会从内核态切换到用户态

3. int指令在ring0和ring3的执行行为有什么不同？

   在ring3执行的时候涉及到特权级的切换，需要保存用户栈的信息，额外把SS和ESP压入内核栈

4. 如何利用int和iret指令完成不同特权级的切换？

   构造一个栈的内容，比如把栈顶CS的CPL和SS的RPL设为3，执行完iret指令后就能切换到用户态

   如果我们把栈顶CS的CPL设为0，执行完iret指令后就能保持在内核态，而不是回到用户态

5. TSS和Task Register的作用是什么？

   TSS保存了0~3特权级的SS和ESP，当我们从用户态切换到内核态的时候，就可以从中获得内核栈的信息

   Task Register保存了TSS段的段选择子，在load Task Register的时候，实际上已经做了缓存，TSS段的基址等信息保存在了Task Register的隐藏位，就省去了去gdt中查找的时间，减少了对内存的访问次数

> [Task state segment](https://en.wikipedia.org/wiki/Task_state_segment)

> Reference: [Intel® 64 and IA-32 Architectures Software Developer Manuals](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring/lecture04?action=AttachFile&do=view&target=325462-sdm-vol-1-2abcd-3abcd.pdf) Page 2897/4684: 7.2.1 Task-State Segment (TSS)

### 7.3 了解段/页表

1. 一条指令执行时最多会出现多少次地址转换？

   两次，段机制实现从虚拟地址到线性地址转换，页机制实现从线性地址到物理地址转换

2. 描述X86-32的MMU地址转换过程；

   根据虚拟地址中的段选择子从全局描述符表GDT中找到段的基址，与偏移量相加，得到线性地址。

   再根据页机制的具体实现，来获得物理地址。如二级页表，先从页目录基址寄存器CR3中获取页目录表的物理地址，加上index，得到页目录项，页目录项中保存了页表基址，加上index，得到页表项，页表项中保存了对应的帧号，左移后加上页内偏移就得到了对应的物理地址

### 7.4 了解UCORE建立段/页表

1. 分析MMU的使能过程，尽可能详细地分析在执行进入保护械的代码“movl %eax, %cr0 ; ljmp $CODE_SEL, $0x0”时，CPU的状态和寄存器内容的变化。

2. 分析页表的建立过程；

   给页目录表分配一个页，并clear这个页，填写页目录项，给页表分配页，并填写页表项来完成线性地址到物理地址的映射。

   先把0XC0000000~0XF8000000(VA)映射到0X00000000~0X38000000(PA)，把0X000000~0X100000(VA)映射到0X000000~0X100000(PA)，设置好CR3（页目录基址寄存器后），将CR0第31位置1，使能页机制，这时更新GDT表，使得段机制完成对等映射，最后把0X000000~0X100000(VA)到0X000000~0X100000(PA)的映射取消